Part I:BASICS
        Ch 1: Getting Started
Getting Python started: done
Getting started in the Python Interpreter
HelloWorld.py

        Ch 2: Variables and Simple Data Types
    Variables
variable = "Thing assigning to variable."
variable = "Thing that replaces old value in variable"
Variables can have letters, numbers, and _
    Can only start with letter or _; No spaces; do not use Python keywords; 
    should be short and descriptive without being overly short or descriptive; 
    be careful with lower-case L and number 1 or capital o or number 0
Can think of variables as boxes, though it can be better to think of them as 
    labels

    Strings
String is series of characters, usually to be displayed to a user, 
    surrounded by ' ', or " "
.title() variable.title() Capitalize words in string
.lower() variable.lower() lower-case words in string
.upper() variable.upper() upper-case words in string
Variables in strings. Two methods, format string and .format();
    f'thing {variable}'; 'string {}  {}'.format(var_1, var_2);
    I do know that there is something to do with % to format strings, though I 
    am not super sure how to use that. I think it is more of a Python 'pre 3.6'
     thing. 
Can do formating to a string and then assign that to a variable
Can use escape \n (newline) and \t (tab) to add white space to a string
.rstrip() variable_string.rstrip() strip all white space to the right 
    of the string permanently 
Be careful about extra whitespace, it can cause problems
.lstrip() strip all white space to the left of the string permanently 
.strip() strip all white space on both sided of the string permanently
Be careful when using single or double quotes inside of strings. Make sure to 
    mix when possible and to use \' \" when needed. 

    Numbers
+ add; - subtract; * multiply; / divide; ** exponents, 
% modulus (remainder); // floor divide (whole number only)
2 + 3*4 is one way to help make readability better by showing order of 
    operations a little more clearly. 
    
    Floats
once a number becomes a float it stays what way until forced to do otherwise. 
Calling a float makes a float, float(), or dividing (/). 
Be careful due to how computers deal with floats, you can sometimes get a crazy
     amount of decimal places. 
Python defaults to a float in any operation that uses a float regardless of 
    what it evaluates to. 
You can use underscored to make large numbers more readable, however Python 
    ignores them 1_000_000 or 1_00_00_00
It is possible to assign multiple variables values on a single line of code; 
    x, y, z = 1, 3, 5 
Python does not have explicit constants, however you can indicate that 
    something is a constant by using ALL_CAPS_IN_THE_VARIABLE_NAME = 4000
    
    Comments
#Comments are notes to yourself and others
#Can be used as TODO, or explane things, or reminders, or whatever you want 
    #them to be used for. 
#There are no block comments in Python
#Good comments are there to remind you what something does after you have to 
    #leave it and come back to it later. Just enough to jog your or someone 
    #elses memory. 
#If something took you more than one or two stabs to figure out how to get 
    #something working it is probably a good idea to comment on it. 
    
    The Zen of Python
In the Python Shell to get the ZoP
>>> import this
The Zen of Python, by Tim Peters
Beautiful is better than ugly...
...
This is the Python community's guiding philosophy. 

        Ch 3: Introducing Lists
    What Is a List?
A list is a data structure that is collection of items in a particular order
As opposed to a dict, tuple, or set (there are others too)
in Python [] square brackets indicate a list
    a_list = [1, 2, 'dog', True, 'happy']
You can access an element in a list by using its index number, (starting at 0 
    (zero))
    >>> a_list[2]
    'dog'
Index positions start at 0 
Be wary of off by one errors
Can use indexed values from a list f'String {variable[0]}'

    Changing, Adding, and Removing Elements
Can modify by directly assigning the new value to the variable index
    variable[3] = 'tommy'
Can add to a list in a few ways
    variable_list.append('sam') adds 'sam' to the end of the list
    variable_list[3].insert('jim') adds 'jim' at index value 3 moving
        everything after index 3 down one index
Can also remove items from a list:
    del variable_list[1] will remove the item from index 1
    variable_list.pop() will remove the last item in the list.
        you can also assign this popped item to another variable
    popped = variable_list.pop()
    variable_list.remove('item to be removed') will remove the first
    instance of 'item to be removed' moving every item after up one 
    index number

    Organizing a List
variable.sort() will permanently sory a list alphabetically
can also do variable.sort(reverse=True) to reverse alphabetize a list
    permenantly
I know this comes up later when talking about slicing a list, but you cannot 
    just assign a list to another variable to preserve the original order of 
    that list. 
    If you do not slice and just list = original_list, when you sort list, 
        original_list will be sorted as well. You must slice the list and the 
        "re-slice" the list in order to return an original order
            You can so this by new_list = old_list[:]
A temporart sorting of a list can be done with the sorted() function
sorted(list) will return the list temporarilly sorted alphabetically.
NOTE: Python does something weird with UPPER and lower case letters (ASCII)
    when sorting them. Be careful when dealing with this so you do not get 
    unexpected behaviors. 
    sorted(list, reverse=True) will also work for sorted. 
It seems like you can not print(list.sort()) but you *CAN* print(sorted(list))
list.reverse() can be used to simply reverse the current list order
    permanently, however this is not so big of a deal since you can 
    list.reverse() a second time to get back to your first order. 
You can len(list_variable) to get the int (starting at 1)of indexes in the list

    Avoiding Index Errors When Working with Lists
Be aware of off-by-one errors
Remember list[-1] to get the last item in a list. This always works except for 
    when the list is empty


        Ch 4: Working with Lists
    Looping Through an Entire List
Looping is useful, huh, who would have thought. 
list_of_n_length
for num in list:
    print(num)
I might be wrong, but for-loops need to be indexable, otherwise it cannot count
    where it is in the loop.
If possible make the "num" part of the loop at least a little descriptive even 
    if it is only a temp variable. Where "num" is the index position variable 
    at that index, in the list being looped. 
You can do almost anything from within a loop. print(f"{num.title()})")
Just remember that it will do this every time it goes through that loop, so be 
    aware of the rammifications. 
As long as every line in the loop is properly indented, you get to stay in the 
    loop. Once you dedent, you are telling Python to stop the loops 
    instructions there. 

    Avoiding Indentation Errors
Indentation is what Python usesto determine how things are related to the rest 
    of the program. 
If you forget to indent immidiately after a line expecting an indent, you will 
    get an error;  
If you forget to continue to indent lines that are supposed to be in the loop, 
    assuming you indented at least one line correctly, you will not get an 
    error, however you *will* get unexpected behaviors; 
        these kinds of errors are called 'Logical Errors'
If you indent when you are not supposed to you will get an 'IndentationError'.
    variable = 1
        print(variable) <- ERROR
If you indent unnesessarily after the completion of a loop, you will get a 
    Logical Error and that (those) line will be included in the loop and the 
    consequences of that.     
Try to remember to not forget the colon. Just dont, syntax error and a feeling 
    of sillyness.

    Making Numerical Lists
Lots of reasons to keep a list of numbers in a program, positions, status, 
    values. All kinds of reasons. 
range()
for num in range(0,11,1) <- ([index to start on], index to stop at but not 
    include, [amount to increment by]) '[]' are optional
list = range(1,5) will give a list of [1,2,3,4] to 'list'
min(list) = 1
max(list) = 4
sum(list) = 10
List Comprehensions
    I do not understand these totally, however I an not totally sure they are 
        necessary. 
squares = []
for value in range(1, 11):
    squares.append(value**2)

print(squares)

^V^V^V same thing ^V^V^V

squares = [value**2 for value in range(1, 11)]
print(squares)

Instructions:
1 begin with a descriptive name for the list
2 open square brackets [ and define the expression for the values you want to 
    store in the new list
3 then write a for loop to generate the numbers you want to feed in to the 
    expression and then close the square brackets ]

Once writing 3 or 4 line lists become tedious consider giving List
    Comprehensions a serious look. 

    Working with Part of a List
Remember that lists are mutable. Becareful when fiddling with them.
slice! Parts of a list
list = [1, 2, 3, 4, 5, 6]
slice_list = list[2:3]
>>> slice_list
[2, 3]
You can work slices a few ways. 
Note lists count by index, like range(6) does; therefore be wary of off by one 
    errors
    list[1:6] list from element 1 to 5
    list[:6] or list[0:6] (these are the same thing)
    list[5:] list to end starting at element 5
    list[:] whole list to copy
    list[-3:] list starting three from the end and going until the end
Can use a for-loop to loop through a slick of elements in a list for num in 
    list[:3]: will give the first three elements in list
Slices are excellent tools for working with parts of lists;
    ex taking a players .sort() top three scores, or looping through data sets 
    with chuncks of data a specific size; or when building a web applicastion, 
    use slices to display info in a series of pages with a good amount of info 
    on each page. 
list_copy = list[:] <- Copy's list

    Tuples
A tuple looks the same as a list except it uses () instead of square brackets. 
tuple = (1, 2, 3, 'string', True)
Tuples are immutable, that cannot be changed without overwriting the whole 
    tuple with a new value. 
To define a tuple with only one element: tuple(8,) put a comma after the first 
    and only element. 
If you try to change something in a tuple, Python will throw an error. 
tuple = (1, 2, 3, 4)
tuple = (11, 13, 15, 17)

    Styling Your Code
Python has an agreed upon number of conventions to endure that code typically 
    reads about the same. 
PEP (Python Enhancement Proposal) is the current standard on how to style code. 
Rule of thumb is to write code that is readable as opposed to easier to write. 
    The reason is, you (should) write your code only once, though you will read
     it many times. 
PEP 8 sayas to use 4 (four) spaces per indentation level. 
*DO NOT* mix tabs with spaces. The interpreter can get confused. 
Each line should be less than 80 characters. 
Comment lines should be less than 72 characters. 
    This is because some tools geet grumpy when these are different. 
Use blank lines to group parts of your code visually
Do not do so excessively
You really do not need more than one line between different sections. 

        Ch 5: if Statements
    Conditional Tests

if-statements can be used to single out special circumstances, like BMW in a 
    list of cars. 
At the heart of every if-statement is a conditional test (True/ False)
>>> car = 'bmw'
>>> car == 'audi'
False
When comparing strings capitalization matters
Checking for inequality != (not)
You can also do numerical comparisons
== equal to
< less than
> greater than
>= greater or equal
<= less or equal
Can also check for multiple conditions on a single line
>>> a == b and b == c
False
>>> a < b and b < c
True
and conditional, if I do not know this by now, please just give up
or conditional, same thing, I actually like this logic stuff. I better know 
    this
You can check to see if something is in a list with 'in' keyword 
    Also, can see if something is 'not in' something 
>>> list = [1, 2, 3,]
>>> 5 in list
False
>>> 2 in list
True
>>> 4 not in list
True
>>> 2 not in list
False
Boolean Expression is another term for conditional expression
Boolean Values will always be either True or False
Boolean Values are often used to keep track of certian conditions; like flags
>>> user_can_edit = False
Efficient way to keep track of the different states of a program. 

    if Statements
super simple
if conditional_test:
    do_something
Can put any conditional test on the first line followed by almost any action 
    in the following block.
Typically try to not ever complicate your if conditional tests. If it gets hard
    to read move it somewhere else and call that variable in the if statement
Indentation plays the same role for if-statements as it did with loops. 
if-else is used to check the if, if the if is False the else *will* run
if-elif-else chains can be used to run down a list of possibible actions based
    on conditionals and run the *first* one the is true. 
The first one that is true bit is super important. Make sure it is possible to 
    hit all of the if-elif-else statements based on all of the possible 
    conditions otherwise the code is pointless. 
Multiple elif blocks can be used. 
Not super sure what to do if the if-elif-else chain becomes super long. There
    is probably a better way to do that, but I am not super positive what that
    solution is at the moment. 
The else block is not required in Python
Sometimes it can be more clear to use a catch all elif statement instead of a 
    else: 
Be careful with else blocks. They are a catch all and will catch bad, invalid,
    or even malicious data. 
if-elif-else can only check one condition. 
    Therefore if you need to you can use multiple if's chained together to test
        many things
You can efficiently check through a list for special values with a for-loop/
    if-statement combination. For example looking through a list to see if 
    certain ingredients are in or out of stock. 
Empty objects return False
    text = ''
    list = []
    therefore you can test with an if to see if something is empty in order to 
        do something interesting with that empty list. e.g. complete level, 
        or confirm a task is complete
    
    Using if Statements with Lists
You can also check to see if something in one list is in another list with 
a for-loop and a if-statement
for thing in list:
    if thing in another_list:
        do_something()

    Styling Your if Statements
PEP 8 says to put a single space around conditionals for if-statements
Good: if 3 < 5:
Not Good: of 3>4:

        Ch 6: Dictionaries
    A Simple Dictionary
Creating this dict
a_dict = {'key':value, 1: 2,}

    Working with Dictionaries
dictionaries in Python are a collection of 'key'-'value' pairs
Acessing the dict is similar to calling a list index except you refer to the 
    key
>>> a_dict['key']
Keys can be ints or strings
Keys or values can be assigned with a variable, however once in the dict if the
    variable changes, the dict will not update
a dict is a collection of key-value pairs. Each key is connected to a value. 
Explicitly, to access a value with a key: a_dict['key']
dicts are dynamic can add or remove from them 
To add a new k-v pair to a dict: a_dict['new_key'] = 'new value'
NOTE: As of Python 3.7 dicts are now ordered. When looping through the order
    the loop goes through the dict will be in the order that the k-v were added
    to the dict
Creating an empty dict is simple: new_dict = {}
Then can work with it like normal. 
In addition to that empty dicts will return false
Changing a value in a k-v pair is the same as assigning a new k-v pair except
    you reuse the key. 
>>> a_dict['key'] = 'happy'
>>> a_dict['key'] = 'smile'
You can remove a k-v pair with >>> del a_dict['key']
This is a permanent deletion, no take-backsies
Dictionarys can be used to store information for one object and its many 
    attributes, and also an atribute of many objects. e.g. a person and facts
    about then vs many people with one response to a poll. 
        This assumes no nesting. 
NOTE: A long dict has PEP 8 formatting that assists readability
a_dict = {
    'a': 1,
    'b': 2, 
    'c': 3,
    'd': 4,
    }
You indent one level "down". 
    There are other ways to format long dicts and other things. Be aware, be 
        alert, be alive!
Use .get() to access things in a list. This will return None (or something else
    if you tell it to do something else) if the 'key' you are attempting to 
    access does not exist. 
>>> variable = a_dict.get('key', 'that does not exist please fix the error')
a_dict['key'] vs a_dict.get('key')
Both work, but should use .get if there is a chance that the key does not exist
    otherwise you will get a KeyError

    Looping Through a Dictionary
Because dicts can be short or long, you can loop through dicts. 
You can loop through dicts in a few ways

    Loop through all k-v pairs
Can loop:
>>>for key, value in user_0.items(): # 'key' and 'value' are variable names and
                                    # can be whatever make it clear what they
                                    # are and are doing. 
        print(key, value)
.items() is a method that returns k-v pairs
the above loop then assigns these pairs to each of the two named variables. 
Looping through all k-v pairs is a good option when you have a dict of object
    and one piece of info e.g. 'person':'primary_language' or dicts with the 
    same 'value-type' for many different keys. 
see favorite_languages.py

    Loop through all keys
.keys() is a useful method when you do not need to work with all of the values
    in a dict
e.g. loop through a dicts 'keys' to find one or more to do something with them. 
NOTE: for keys in a_dict.keys(): is the same thing as for keys in a_dict:
.keys() is the default value for the dict to be iterated over. 
.keys() is not just for looping. It returns a list of all 'keys'. 
    Loop through keys in a particular order
sorted(a_dict.keys()) is an option. 
Not a whole lot here, but it might be useful when printing something to a user
    Loop through all values in a dict
.values() is an option in the same way that .keys() is an option. 
This is if you need to only loop through the values of a dict. 
In this example: 
set(a_dict.values()) is used to creat a set of the values in the dict. A set 
    is used to identify unique items in a list and only display one instance of
    them. In this example it was for when there were multiple people with the
    same favorite language. 
A set is a unordered collection with no duplicate elements
You create a set with either set(something_not_a_set) or with a_set = {'dog'}
NOTE: you cannot create an empty set with a_set = {}. This would create a dict.
empty_set = set()

    Nesting
This is when you want to store something *in* something else. List in list, or
dict in list, or set in dict.
List of dicts
a_dict = {'a':'1'}
b_dict = {'b':'2'}
c_dict = {'c':'3'}
a_list = [a_dict, b_dict, c_dict]
List in dict
a_dict = {'a_key':'a_value', 'b_key': ['a_list', 'b_list',]}
this shows a couple of things, in addition to the list in a dict ex.
It showes that a value in a dict does not need to always be the same type of 
    object that other values in the dict are. 
When you have a long print call and you need to break it up over several line, 
    you will close the string with ' or " and then on the next line, intent one
    level and then open the ' or " again and continue the string. 
You can nest a list inside a dict any time you want a key to have more than one
value associated with it. E.g. people and their list of favorite programming
    languages
NOTE: DO NOT NEST TO DEEPLY FOR IT IS GREEDY AND WILL AWAKEN NASTY BEASTS,
    there is also probably a better way to do it. 
Dicts can do in dicts. 
    users{'user':{'dict_of_user_facts'}}
Keep the structure of dicts within dicts the same. It will make this much 
    easier to read. 

        Ch 7: User Input and while Loops
    How the input() Function Works
input() pauses the program and waits for the user to type in text. It then 
    converts that text to a string, and then if it is told to, assigns that 
    string to a variable. 
input takes one parameter that is a string and that becomes the prompt for the 
    input
input('> ')
NOTE: Many editors do not run programs with input correctly, probably will need
    to use the Terminal
Can use the prompt parameter to ask questions or just give a typing prompt 
    indicator
Unless your instructions should be clear and easy-to- follow/understand. Need 
    to also seperate the instruction text from the users input to make it clear
    something is expexted from the user. 
Can help to use a colon then a space at the end of the prompt
When the prompt is longer than one line, (including when you use a second line
    for further instructions) you should create a variable and increment/
    concatenate the string together. 
    NOTE this is *ONE WAY* to build a multi-line string. 
    NOTE: I am not sure specifically if this is best practice or just how Eric
        does this. 
variable = 'Do the thing user!'
variable += '\nFurther instructions for clarification user! '
action = input(variable)
input() puts everything the user types in to a string. If you expect a number, 
    you will need to convert that 'str' in to an int with int(user_input) 
    before trying to manipulate that number with number things.
If you forget to int() you should get a TypeError
Modulo is a very useful tool for working with numerical information. 
It specifically takes a number and divides it by another number and returns the
    remainder. 
It does not tell you how many times a number fits in to another number, *ONLY*
    the remainder. 
REMEMBER: Modulo any number by 2 and if 0, then the number is even, if 1, the 
    number is odd. 

    Introducing while Loops
for-loop takes each item in an iterable thing (set, list, dict, tuple, 
    something... else?) and loops over it once for each item in that collection
a while-loop repeats until the condition that sets the loop is true.
while True: <- Will loop forever unless something breaks out of the loop. 

while a_number is <= 399:
    do something.
MAKE SURE: that the loop will eventually become false or something breaks out 
    of the loop, or you will need to wait for the heat death of the universe. 
Quiting a while loop can be based on many things. User input, a flag that
    changes to false, *ANYTHING* that can become false, or break out of the 
    loop. 
while user_input != 'quit':
Be wary for user_input strings to 'quit', you might still have to go through 
    the loop one more time depending on how you have the loop set up. 
    An if statement can help with that to short circuit out of the loop exactly
    when you want to. 
Flags - setting a variable to True or False and then changing that variable 
    to change a conditional can be simpler than while True and can allow for
    impact beyond a function. 
    e.g. A program where there are many things should cause the conditional to
        stop the loop. This program should only run as long as many 
        conditionals are true
The keyword break can be used to immediately end any loop without running any
    remaining code in that block. This allows you to more elequantly control 
    exactly the code you want to run in a loop. 
The keyword continue will restart the loop from that point without finishing 
    that loop... of the loop. Immediately to the top of the loop. 
You need to avoid an infinite loop. Everything needs a way out.
If you get stuck in an infinite loop Crtl-c will interupt the program forcing a
    stop. Or just close the window. 
Thoroughly test your loops to make sure that they can and will exit the loop
    eventually. Especially when the exit conditions are subtle. 

    Using a while Loop with Lists and Dictionaries
You should not modify a list while looping through the list else Python (and 
    you) will get lost, dazed, and confused. 
while-loops with list and dicts allows for collecting, using, storing, and 
organizing input to examine and report later. 
No for-loop, .pop() from one list to another will not work. 
remove('string') will only remove one instance of the object you want to remove
    from that list. You can while-loop many times to make sure all instances
    of that thing are removed from the whole data structure. 
Can use input() with a while loop to recieve many responses from a user until 
    they indicate that their data entry is complete. 'quit' 'end' whatever. 

        Ch 8: Functions
    Defining a Function
Functions are named blocks of code that do one thing. 
When you want to run that code you 'call' a function. 
This saves typing and increases modularity and readability. 
Functions can process data, or display it. (Plus all of the other things)
>>> def do_a_function():
>>>     do_code_things

>>> do_a_function()
THINGS HAPPEN!

Will also need to pass information in to the function. 
>>> def do_a_function(something_fun_needs):
>>>     do_code_things + something_fun_needs

>>> do_a_function(some_variable)
MORE THINGS HAPPEN!
NOTE: A parameter is a piece of information that a function needs to do its job
NOTE: An argument is the piece of informatino that is passed to the function
    so it can do its job. 
The difference is that a parameter is the definiaiton of what the function 
    needs and an argument is that actual info that is given to the function. 

    Passing Arguments
functions can require many parameters, a function call will need many arguments
There are many ways to pass arguments to the function. 
    Postitional Arguments
These arguments must be in the correct specific order in the function call as 
    defined in the function. 
>>> def thing(arg1, arg2, arg3)

>>> cheese = thing(a_arg1, b_arg2, c_arg3)
Otherwise everything will get confused and will not work. 
NOTE: You can call a single function multilple times with no issues. 
This in fact can be a very efficient way to work. 
Order matters in Positional Arguments!
>>> cheese = thing(b_arg2, a_arg1, c_arg3) <- Will ruin everything
    Keyword Arguments
Keyword Argument is a 'key'-'value' pair you pass in a function. 
The value is directly associated with the key so you cannot get out of order
    arguments like with positional arguments. 
Keyword Arguments do not need to be in order
>>> cheese = thing(a_arg1='taste', c_arg3=42, b_arg2='foo')
NOTE: NEED TO LOOK IN TO COMBINING POSITIONAL AND K-V ARGUMENTS
    PROBABLY NOT BEST TO MIX AND MATCH THESE
    Default Values
You can assign a parameter to a default value in case it is not always needed
    or not required
Default values must go at the end of the arg list
>>> def thing(a_arg1, b_arg2, c_arg3=42)
>>> cheese = thing(12, 'fancy')
When no value is used in the argument for the parameter with a default value, 
    then the default is assigned to that parameter, this is kind of obvious, 
    I just want to make sure future Brayton understands this. 
It does not matter what calling style you use, however, try to use the one 
    that makes thing the most clear and easy to read. 
An argument error will happen when python expexts a certian number of arguments
    and a different number is provided
    (I am looking at you 'self')
TypeError: function_cool() missing 2 required positional arguments: 'thing1' 
and 'thing2'
If your names for args and params are clear solving the problems should be 
    super simple to find out what is exactly going wrong. 
    Return Values
The value that something gives back to what called it is called a return value
This allows much of the grunt work to move to functions. 
When calling a function that returns something it needs a variable that Python
    can assign that returned value to. 
This might seem like a lot of work for something simple, however when moving on
    to working with lots and lots of things it helps. 
It is possible to make an argument optional
Simply assign the parameter to a default value of None or an equivalent value
You can use if statements to control what happens when one of the arguments
    is not used
For conditional tests None evaluates to False in Python
Back to while-loops, make sure that they have a way out of them. Yadda-yadda
    heat death.
input('quit') etc
    Passing a List
Using functions with lists can make working with lists more efficient. 
The when passing a list to a function, the function is given access to the 
whole list. 
This is useful for looping through lists
You can make changes to a list within the function. These changes to the list
are permenent. Excepting when passed a slice or a copy.copy or copy.deepcopy


###STOPPED TOP PAGE 143

    Passing an Arbitrary Number of Arguments

    Storing Your Functions in Modules

    Styling Functions



        Ch 9: Classes

        Ch 10: Files and Exceptions

##### STOPPED pg 184

        Ch 11: Testing Your Code